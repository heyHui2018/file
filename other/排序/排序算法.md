#分类
##1.非线性时间比较类
    ——交换排序——冒泡/快速
    ——插入排序——简单插入/希尔
    ——选择排序——简单选择/堆
    ——归并排序——二路归并/多路归并
##2.线性时间非比较类
    ——计数/桶/基数

#复杂度
![复杂度](../../pic/复杂度.png)
    ——稳定：若a在b前面且a=b,则排序后a仍在b前面
    ——不稳定：若a在b前面且a=b,排序后a可能会在b后面

##冒泡排序
###1.基本思想
两个数比较大小，大数下沉，小数冒出。
###2.过程
####A.比较相邻两个数，若后者较小，则交换
####B.从前向后两两比较，最终最大数被交换到最后位置
####C.对所有元素重复上述步骤，除了最后一个
![冒泡排序](../../pic/冒泡排序动图.gif)

##快速排序
###1.基本思想
通过一趟排序将数列分成两部分，一部分中的数均比另一部分小，分别对这两部分进行排序。
###2.过程
####A.从数列中挑出一个元素，称为“基准”
####B.遍历数列，比基准小的放在基准前面，大的放在基准后面，此为分区操作
####C.递归地把小于基准的子数列和大于基准的子数列进行排序
![快速排序](../../pic/快速排序动图.gif)

##简单插入排序
###1.基本思想
构建有序序列，对于未排序数列，在有序数列中从后向前扫描，找到相应位置并插入
###2.过程
####A.从第一个元素开始，此元素可以被视为已排序
####B.取下一元素，在已排序的队列中从后向前扫描
####C.若已排序的元素大于新元素，则将已排序的元素向后移
####D.重复C直到已排序的元素小于或等于新元素
####E.将新元素插入到已排序的元素之后
####F.重复B-E
![简单插入排序](../../pic/简单插入排序动图.gif)
###3.分析
通常采用in-place排序（只需用到O(1)的额外空间），所以在从后向前扫描过程中，需要反复把已排序的元素逐步向后挪

##希尔排序
###1.基本思想
简单插入排序改进版，不同之处在于将整个待排序的数列分成若干个子序列进行直接插入排序，又称缩小增量排序
###2.过程
####A.选择一个增量序列t1,t2,...,tk,其中ti>tj,tk=1
####B.根据k对待排序列进行k趟排序
####C.每趟排序，根据对应的增量ti，将待排序列分成若干个长度为m的子序列，分别对子序列进行直接插入排序。当k=1时，待排序列作为一个数列处理，长度即全长
![希尔排序](../../pic/希尔排序动图.gif)
###3.分析
核心在于间隔序列的设定

##简单选择排序
###1.基本思想
在待排序数列中找到最小（大）元素，存放到排序序列的起始位置，然后继续寻找剩余的最小（大）值，放到已排序序列的末尾，以此类推。
![简单选择排序](../../pic/简单选择排序动图.gif)
###2.分析
最稳定排序算法之一，时间复杂度始终是O(n2)，唯一的好处是不占用额外的内存空间

##堆排序
###1.基本思想
利用堆的数据结构——近似完全二叉树的结构，又同时满足堆积的性质——子节点的键值或索引总是小于或等于其父节点
###2.过程
####A.将待排序数列（R1,R2,...,Rn）构建成大顶堆，此堆为初始的无序区
####B.将堆顶元素R[1]与最后一个元素交换，此时得到新的无序区（R1,R2,...,Rn-1）和新的有序区（Rn），且满足R[1,2...n-1]<=R[n]
####C.交换后的新堆顶可能违反堆的性质，需对当前无需去（R1,R2,...,Rn-1）进行调整，然后再将R[1]与无序区最后一个元素进行交换，得到新的无序区（R1,R2,...,Rn-2）和新的有序区（Rn-1，Rn）
####D.重复上述步骤
![堆排序](../../pic/堆排序动图.gif)

##归并排序
###1.基本思想
采用分治法，将已有序的子序列合并，即先对子序列排序，再使各子序列段间有序，若只将两个有序表合并成一个称为二路归并。
###2.过程
####A.把长度为n的待排序数列分成两份长度为n/2的子序列
####B.对子序列采用归并排序
####C.将两个排序好的子序列合并成一个最终的有序序列
![归并排序](../../pic/归并排序动图.gif)
###3.分析
最稳定的排序算法之一，时间复杂度始终是O(nlogn)，代价是需要额外的内存空间

##计数排序
###1.基本思想
将输入的数据转化为键存储在额外开辟的数组空间中，这要求输入的数据是有确定范围的整数
###2.过程
####A.找出待排序的数组中最大和最小的元素
####B.统计数列中每个值为i的元素的出现次数，存入数组C的第i项
####C.对所有计数累加（从C中的第一个元素开始，每一项和前一项相加）
####D.反向填充目标数组：将每个元素i放在新数组的第C（i）项，每放一个元素就将C（i）减一
![计数排序](../pic/计数排序动图.gif)
###3.分析
稳定的排序算法，当输入的元素是n个0-k之间的整数时，时间复杂度是O(n+k),空间复杂度也是O(n+k)，排序速度快于任何比较排序算法

##桶排序
###1.基本思想
计数排序的升级版，利用了函数的映射关系，高效与否的关键在于这个映射函数的确定。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（可使用别的排序方法，也可用递归方式继续使用桶排序）
###2.过程
####A.设置一个定量的数组当空桶
####B.遍历输入数据，将其一一放到对应的桶中
####C.对每个不是空的桶进行排序
####D.从不是空的桶中拿出排好序的数据进行拼接
![桶排序](../../pic/桶排序图.gif)
###3.分析
最好情况下时间复杂度为O(n)，其时间复杂度取决于各桶见数据进行排序的时间复杂度。显然桶分的越小，其中数据就越少，排序时间就越短，但会消耗更多空间

##基数排序
###1.基本思想
按照低位先排序，然后收集，再按照高位排序，再收集，以此类推知道最高位。
###2.过程
####A.取得数列中的最大数，并取得位数
####B.arr为原始数组，从最低位开始取每个位组成radix数组
####C.对radix进行计数排序
![基数排序](../../pic/基数排序动图.gif)
###3.分析
基数排序性能要比桶排序差