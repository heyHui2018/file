23 合并k个链表 合并,链表,k个,归并 两两合并,递归,
24 翻转前后两个字节 翻转,链表,前后字节 计数,偶数位时与前一位翻转
25 翻转k个字节(顺序变更) 翻转,链表,连续k个字节 将各节点放入list,当累计到k个时,将其翻转(for循环),需注意当链表长度为k的倍数时,因判断条件是.Next==nil,所以在最后还需将最后一个节点加入list并进行翻转
26 返回数组中不同元素的个数 数组,空间复杂度O(1),首首扫描 a/b同时从头扫描,a=b时,b继续往后,!=时a++然后和b交换值,b继续往后直到结束 
27 删除数组中值为val的元素 数组,删除,首尾扫描 同时从首尾开始扫描,首取等于val的位置,尾取不等于val的位置,然后互换,直到首尾扫描相交则结束
28 判断字符串是否完全包含子串 字符串,包含 遍历字符串,当字符与子串第一个字符匹配时,直接截取字符串与子串比较,相等则返回该字符的索引,否则继续遍历
29 计算商 除法,注意溢出 先定符号,随后除数循环减被除数,直到除数比被除数小为止,最终检查溢出
30 判断字符串是否完全包含数组中的子串(任意一种组合) 字符串,数组,包含,滑动窗口,任意一种组合 生成数组对应的map,value记录对应子串的应匹配次数,遍历字符串,取left和right,left作为匹配开始点,right作为子串长度滑动窗口开始点,判断map中是否存在窗口中的单词,若存在且value>0,则value-1,已匹配次数+1(当已匹配次数与数组长度相等时,记录此时的left,并右移left),窗口向后滑动,若存在但value=0,则left右移,直到value=1为止,然后继续滑动窗口,若不存在,则left和right均指向窗口后的下一个单词,随后继续滑动窗口.当
31 将数组重新排列成比原排列在字典序中下一个更大的排列 数组,排序,字典序中下一个更大的排列 从后往前找到最长降序序列,将其转换为升序序列,把序列前的元素与序列中第一个大于他的元素互换.当发现是纯降序序列即已是最大值时,将其转为最小值
32 查找最长的括号组合 括号组合,最长 先生成每个字符状态的数组,若能和前面配对上,则记为2否则为0,再从左开始检查,若record[i]==2,record[j]==0,且record[j+1:i]中没有0,则record[i]=1,record[j]=1,最后统计数组中最多的连续为1的次数
33 在被翻转的有序不重复数组中查找指定值 有序数组,翻转,不重复,二分查找 先计算旋转距离,随后还原数组进行二分查找时间复杂度O(logn)
34 在有序可重复数组中查找指定值最前/最后的index 有序数组,可重复,查找最前/最后index,二分查找 二分查找,当中间值=目标值时向前后遍历以找到目标值的最前/最后index
35 在有序不可重复数组中找出指定值或此值可被插入的index 有序数组,不可重复,二分查找 二分查找,在迭代中考虑mid的前一位/后一位与target的关系
36 判断数独是否有效 数独,依次检查 依次检查行、列、3*3小方格是否无重复
37 填充数独 数独,遍历填充 遍历数独,依次往'.'的位置填充1-9,随后校验是否和行、列、块造成冲突,若1-9都有冲突,则失败,否则继续
38 根据数字大小生成读法字符串,如1是一,2是在1的基础上处理,1个一即11,3是在2的基础上处理,2个1即21,以此类推 读法字符串 通过for循环实现后一个数在前一个数基础上处理
39 返回数组中数组成目标值的所有组合(数组无重复,数可重复使用) 所有组合,递归,减少余数或减少选择项 先对数组进行排序,随后取出第一个数,出现2种情况:1、余数由数组中的数组成;2、目标数由数组中的其余数组成;以此类推直至余数为0(采纳)或余数小于数组中剩余最小数(丢弃)或数组中无选择项(丢弃)
40 返回数组中数组成目标值的所有组合(数组有重复,数仅可使用一次) 所有组合,递归,减少余数且减少选择项 先对数组进行排序,随后取出第一个数,出现2种情况:1、余数由数组中其余数组成;2、目标数由数组中其余数组成;以此类推直至余数为0(采纳)或余数小于数组中剩余最小数(丢弃)或数组中无选择项(丢弃)
41 返回未排序数组中缺失的最小正整数 数组,未排序,最小正整数,空间复杂度O(n)且空间复杂度O(1) 明确取值空间在[1,len(nums)+1],可用nums[k]存放k+1,当某个k存放的不是对应的k+1时,结果便是此k+1,nums[i] != nums[nums[i]-1] 即 k+1 != nums[k],则将其交换位置,通过for循环交换,最终会将1/2/3...放到其位置上(若nums中存在的话),若nums中不存在,则其位置为其余数,在最后遍历nums即可发现
42 返回数组的储水量 数组,储水量 i点的存水量为min(max(height[:i+1]...), max(height[i:]...)) - height[i],取left数组存储height[:i+1]中的最大值,取right数组存储height[i:]中的最大值,然后取i同时遍历两数组,取left,right中对应较小的
43 返回两个数字组成的string的乘积 字符串,乘积,乘法分解 因乘积的长度一定为两数长度之和或长度之和-1,故设长度为两数长度之和的int数组用于存放各位乘积.乘法可分解为a的第i位与b的第j位相乘,乘积为结果的第i+j+1位,再统一处理进位及最高位的判断,再转换成string
44 判断s能否被p匹配 字符串,匹配,?及* 记录上一个*的位置及*对应匹配s中字符的位置,当出现不匹配又不是?和*时,若出现过*,则回滚,使*继续匹配这次的字符,若没出现过*则返回false,当s已完成匹配而p未完成时,只有p中剩余的均为*时才返回true
45 返回最小跳数 数组,最小跳数 确保每次跳都是最远的,目前的位置+能跳的最大距离即index+nums[index]在nums[i+1:i+nums[i]+1]中是最大的
46 返回不重复数组中数字能组成的所有组合 数组,所有组合,不重复 递归,当前组合的结果基于其子集的结果,如当前组合为{1,2},则有两种组合1-2和2-1,则{1,2,3}有3-1-2,1-3-2,1-2-3,3-2-1,2-3-1,2-1-3 6中组合,在{1,2}的2种组合的基础上产生的
47 返回有重复数组中数字能组成的所有不重复组合 数组,所有不重复组合,有重复 递归,当前组合的结果基于其子集的结果,如当前组合为{1,2},则有两种组合1-2和2-1,则{1,2,3}有3-1-2,1-3-2,1-2-3,3-2-1,2-3-1,2-1-3 6中组合,在{1,2}的2种组合的基础上产生的,在迭代过程中通过map去重
48 