23 合并k个链表 合并,链表,k个,归并 两两合并,递归,
24 翻转前后两个字节 翻转,链表,前后字节 计数,偶数位时与前一位翻转
25 翻转k个字节(顺序变更) 翻转,链表,连续k个字节 将各节点放入list,当累计到k个时,将其翻转(for循环),需注意当链表长度为k的倍数时,因判断条件是.Next==nil,所以在最后还需将最后一个节点加入list并进行翻转
26 返回数组中不同元素的个数 数组,空间复杂度O(1),首首扫描 a/b同时从头扫描,a=b时,b继续往后,!=时a++然后和b交换值,b继续往后直到结束 
27 删除数组中值为val的元素 数组,删除,首尾扫描 同时从首尾开始扫描,首取等于val的位置,尾取不等于val的位置,然后互换,直到首尾扫描相交则结束
28 判断字符串是否完全包含子串 字符串,包含 遍历字符串,当字符与子串第一个字符匹配时,直接截取字符串与子串比较,相等则返回该字符的索引,否则继续遍历
29 计算商 除法,注意溢出 先定符号,随后除数循环减被除数,直到除数比被除数小为止,最终检查溢出
30 判断字符串是否完全包含数组中的子串(任意一种组合) 字符串,数组,包含,滑动窗口,任意一种组合 生成数组对应的map,value记录对应子串的应匹配次数,遍历字符串,取left和right,left作为匹配开始点,right作为子串长度滑动窗口开始点,判断map中是否存在窗口中的单词,若存在且value>0,则value-1,已匹配次数+1(当已匹配次数与数组长度相等时,记录此时的left,并右移left),窗口向后滑动,若存在但value=0,则left右移,直到value=1为止,然后继续滑动窗口,若不存在,则left和right均指向窗口后的下一个单词,随后继续滑动窗口.当
31 将数组重新排列成比原排列在字典序中下一个更大的排列 数组,排序,字典序中下一个更大的排列 从后往前找到最长降序序列,将其转换为升序序列,把序列前的元素与序列中第一个大于他的元素互换.当发现是纯降序序列即已是最大值时,将其转为最小值
32 查找最长的括号组合 括号组合,最长 先生成每个字符状态的数组,若能和前面配对上,则记为2否则为0,再从左开始检查,若record[i]==2,record[j]==0,且record[j+1:i]中没有0,则record[i]=1,record[j]=1,最后统计数组中最多的连续为1的次数
33 在被翻转的有序不重复数组中查找指定值 有序数组,翻转,不重复,二分查找 先计算旋转距离,随后还原数组进行二分查找时间复杂度O(logn)
34 在有序可重复数组中查找指定值最前/最后的index 有序数组,可重复,查找最前/最后index,二分查找 二分查找,当中间值=目标值时向前后遍历以找到目标值的最前/最后index